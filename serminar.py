# -*- coding: utf-8 -*-
"""SERMINAR.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ZFKhAv8HkvT_YdjB5Cnq6I0a26_5Io-_

## **Nhóm 5**
Lâm Thanh Vi - K224141744 - Nhóm trưởng

Phạm Thụy Phương Dung - K224141715

Đoàn Tuấn Nghĩa - K224141730

Nguyễn Sơn Trường - K224141742

Lê Nguyễn Tường Vy - K224141746

## **Import Data**
"""

import pandas as pd
import numpy as np
import seaborn as sns
import plotly.express as px
import warnings
from matplotlib import pyplot as plt
# Ignoring warnings
warnings.filterwarnings('ignore')

# Import data
url = 'https://drive.google.com/file/d/1lYD9C1Ke1xbDd0UVb4ChpFDqTtZUhnmJ/view?usp=sharing'
url = 'https://drive.google.com/uc?id=' + url.split('/')[-2]
df = pd.read_csv(url)
df

"""## **Data processing**

"""

df.info()

df.describe()

df.shape

"""## **Normal distribution chart**"""

import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
from scipy.stats import norm


# Identify Numerical and Categorical Columns
numerical_columns = df.select_dtypes(include=['int64', 'float64']).columns
categorical_columns = df.select_dtypes(include=['object', 'bool']).columns

# Generate Plots for Numerical Columns
nrows = int(np.ceil(len(numerical_columns) / 4))
ncols = min(4, len(numerical_columns))

fig, axes = plt.subplots(nrows, ncols, figsize=(15, 10))
for i, ax in enumerate(axes.flat):
    if i < len(numerical_columns):
        column_name = numerical_columns[i]
        column_data = df[column_name]  # Use 'df' instead of 'data'

        if np.isnan(column_data).any():
            # Handle NaNs if present
            pass

        n, bins, patches = ax.hist(column_data, density=True, alpha=0.7)
        mu = column_data.mean()  # Calculate mean
        std = column_data.std()  # Calculate standard deviation
        ax.plot(bins[:-1], norm.pdf(bins[:-1], loc=mu, scale=std),
                linewidth=2, color='r', label='PDF')
        ax.set_xlabel(column_name)
        ax.set_ylabel('Density')
        ax.set_title(f'Distribution of {column_name}')
        ax.legend()
    ax.margins(0)
plt.tight_layout()

# ... (rest of the code for categorical columns remains the same)

# Display Plots
plt.show()

import pandas as pd
import matplotlib.pyplot as plt
# Create a scatter plot of 'Exited' vs 'Age'
plt.figure(figsize=(12, 7))
plt.scatter(df['Exited'], df['Age'], alpha=0.5)
plt.title('Exited vs Age')
plt.xlabel('Exited')
plt.ylabel('Age')
plt.grid()
plt.show()

"""## **Data cleaning**"""

# Xóa 3 cột: RowNumber, CustomerID, Surname
df = df.drop(columns = ['RowNumber','CustomerId','Surname'])
df

# Kiểm tra cột Balance
df['Balance'].describe()

# Thay thế các giá trị 0 bằng giá trị mean
df['Balance'].replace(0, round(df.Balance.mean(),2), inplace=True)
df

## Kiểm tra các giá trị bị thiếu
for i in df.columns:
    print("Feature",i,"has",df[i].isna().sum(),"missing values.")
    print('---'*20)

## Loại bỏ các giá trị trùng lắp
df.drop_duplicates(inplace=True)
print("Duplicated values dropped succesfully")
print("*" * 80)

"""## **Categorical and Continuous Variables**"""

Categorical_list = ['HasCrCard', 'IsActiveMember', 'Exited']
plt.figure(figsize = (20,20)) # size bảng 20*20
for i in range(len(Categorical_list)): #length = 5 0->4
    plt.subplot(3,2,i+1)
    sns.countplot(x = Categorical_list[i], palette='Set2', data = df)

Continuous_list = ['CreditScore', 'Age', 'Tenure','Balance', 'NumOfProducts', 'EstimatedSalary']
# chỉnh kích thước và màu sắc
plt.figure(figsize = (20,13))
sns.set(color_codes = True)

# https://seaborn.pydata.org/generated/seaborn.displot.html#seaborn.displot
for i in range(len(Continuous_list)):
    plt.subplot(3,2,i+1)
    sns.distplot(df[Continuous_list[i]], kde = False)

"""## **Finding outliers**"""

numeric_columns = (list(df.loc[:, Continuous_list]))
def boxplots_custom(dataset, columns_list, rows, cols, suptitle):
    fig, axs = plt.subplots(rows, cols, sharey=True, figsize=(16,3))
    fig.suptitle(suptitle,y=1, size=25)
    axs = axs.flatten()
    for i, data in enumerate(columns_list):
        sns.boxplot(data=dataset[data], orient='h', ax=axs[i])
        axs[i].set_title(data + ', skewness is: '+str(round(dataset[data].skew(axis = 0, skipna = True),2)))
boxplots_custom(dataset=df, columns_list=numeric_columns, rows=2, cols=3,suptitle='Boxplots for each variable')
plt.tight_layout()

"""## **Handling outliers**"""

# Xử lý các ngoại lệ bằng phân phối chuẩn
from scipy import stats
print("Number of rows before filtering outliers:", len(df))

filtered_entries = np.array ([True] * len(df))

for col in Continuous_list:
    zscore = abs(stats.zscore(df[col]))
    filtered_entries = filtered_entries & (zscore < 3)
df = df[filtered_entries]
print("Number of rows after filtering outliers:",len(df))

"""## **Checking remaining outliers**"""

# Các ngoại lệ (outliers) chưa được loại bỏ là những outliers không tuân theo phân phối chuẩn
numeric_columns = (list(df.loc[:, Continuous_list]))
def boxplots_custom(dataset, columns_list, rows, cols, suptitle):
    fig, axs = plt.subplots(rows, cols, sharey=True, figsize=(16,3))
    fig.suptitle(suptitle,y=1, size=25)
    axs = axs.flatten()
    for i, data in enumerate(columns_list):
        sns.boxplot(data=dataset[data], orient='h', ax=axs[i])
        axs[i].set_title(data + ', skewness is: '+str(round(dataset[data].skew(axis = 0, skipna = True),2)))
boxplots_custom(dataset=df, columns_list=numeric_columns, rows=2, cols=3,suptitle='Boxplots for each variable')
plt.tight_layout()

"""## **Handling outliers by another way**"""

# Loại bỏ các giá trị outliers của cột Age (những giá trị lớn hơn 60)
outliers_age = df[df['Age'] > 60]
df = df.drop(outliers_age.index)
df

# Loại bỏ các ngoại lệ của cột CreditScore (những cột có giá trị nhỏ hơn 400)
outliers_crescore = df[df['CreditScore'] < 400]
df = df.drop(outliers_crescore.index)
df

"""## **Data Transformation**"""

# Chuẩn hoá dữ liệu (phương pháp Standardization)
# Chia tỷ lệ dữ liệu số
from sklearn.preprocessing import StandardScaler
scaler = StandardScaler()
df[['CreditScore', 'Balance', 'EstimatedSalary']] = scaler.fit_transform(df[['CreditScore', 'Balance', 'EstimatedSalary']])
df

# Chuyển đổi dữ liệu phân loại thành dữ liệu số
from sklearn.preprocessing import LabelEncoder
le = LabelEncoder()
df['Geography'] = le.fit_transform(df['Geography'])
df['Gender'] = le.fit_transform(df['Gender'])
df

# Vẽ biểu đồ phân phối Pairplot
sns.pairplot(data = df, hue = 'Exited')

df.Exited.value_counts()

X = df.drop('Exited', axis=1)
y = df['Exited']

pip install imblearn

from collections import Counter
from imblearn.over_sampling import SMOTE
smote = SMOTE()
X_train_smote, y_train_smote = smote.fit_resample(X, y)

print("Before: ", Counter(y))
import pandas as pd
# Hiển thị số lượng các lớp sau khi cân bằng
class_counts = pd.Series(y_train_smote).value_counts()
print("Số lượng lớp 0 sau khi cân bằng:", class_counts[0])
print("Số lượng lớp 1 sau khi cân bằng:", class_counts[1])

import pandas as pd
from collections import Counter

# Assuming X_train_smote and y_train_smote are NumPy arrays

# Create a DataFrame from X_train_smote with columns from df (excluding the target column)
b_df = pd.DataFrame(X_train_smote, columns=df.columns[:-1])

# Add the target column 'Exited' to b_df using y_train_smote
b_df['Exited'] = y_train_smote

# Concatenate the balanced data (b_df) with the original data (df)
df = pd.concat([b_df], ignore_index=True)
# Access the 'Exited' column directly

print("Class distribution:", Counter(df['Exited']))  # Access the 'Exited' column directly

df.value_counts("Exited").plot.pie(autopct = "%1.f%%") #Biểu đồ tròn
df.value_counts("Exited")

import matplotlib.pyplot as plt
plt.hist(df['Exited'])
plt.show()

"""## **Dimension reduction**"""



y

df.shape

"""## **PyCaret Binary Classification**"""

!pip install pycaret pandas shap

import pandas as pd
import numpy as np
import warnings

# Ignoring warnings
warnings.filterwarnings('ignore')

from sklearn.model_selection import train_test_split, cross_val_predict, KFold
from sklearn.metrics import classification_report
from imblearn.over_sampling import SMOTE
from sklearn.preprocessing import LabelEncoder
from sklearn.linear_model import LogisticRegression

df

# Set up
import pandas as pd
from pycaret.classification import *
from sklearn.model_selection import train_test_split

clf1 = setup(df, target = 'Exited', session_id = 123)
print(clf1)

# Compare baseline models
best_model = compare_models()

# Evaluate model
evaluate_model(best_model)

# Analyze model
# plot confusion matrix
plot_model(best_model, plot = 'confusion_matrix')
# plot AUC
plot_model(best_model, plot = 'auc')
# plot feature importance
plot_model(best_model, plot = 'feature')
# plot class report
plot_model(best_model, plot = 'class_report')

# predict on test set
predict_model(best_model)

# save pipeline
save_model(best_model, 'phantichdulieu')

# load pipeline
loaded_best_pipeline = load_model('phantichdulieu')
loaded_best_pipeline

# compare model
best_recall_models_top3 = compare_models(sort = 'Recall', n_select = 3)

blend_models(best_recall_models_top3)

# create model
# train knn model
knn = create_model('knn')
plot_model(knn, plot = 'confusion_matrix')
plot_model(knn, plot = 'auc')
plot_model(knn, plot = 'class_report')
predict_model(knn)

# train dt model
dt = create_model('dt')
plot_model(dt, plot = 'confusion_matrix')
plot_model(dt, plot = 'auc')
plot_model(dt, plot = 'feature')
plot_model(dt, plot = 'class_report')
predict_model(dt)

# train svm model
svm = create_model('svm')
plot_model(svm, plot = 'confusion_matrix')
plot_model(svm, plot = 'feature')
plot_model(svm, plot = 'class_report')
predict_model(svm)

# train lr model
lr = create_model('lr')
plot_model(lr, plot = 'confusion_matrix')
plot_model(lr, plot = 'auc')
plot_model(lr, plot = 'feature')
plot_model(lr, plot = 'class_report')
predict_model(lr)

"""## **Correlation Heatmap**"""

import seaborn as sns

# Calculate correlation
correlation = df[['CreditScore', 'Geography', 'Gender', 'Age', 'Tenure', 'Balance', 'NumOfProducts', 'HasCrCard', 'IsActiveMember', 'EstimatedSalary']].corr()

# Plot heatmap of correlation
plt.figure(figsize=(10, 8))
sns.heatmap(correlation, annot=True, cmap='coolwarm', center=0, linewidths=0.5)  # Add linewidths for gridlines
plt.title('Correlation Heatmap')
plt.xticks(rotation=45)  # Rotate x-axis labels for better readability with many features
plt.yticks(rotation=0)  # Keep y-axis labels horizontal
plt.show()

"""## **Adjust Correlation Heatmap**"""

import pandas as pd
import matplotlib.pyplot as plt

# Assuming 'df' is your DataFrame
gender_excited_counts = df.groupby('Gender')['Exited'].value_counts().unstack()

# Create a bar chart
gender_excited_counts.plot(kind='bar', color=['blue', 'green'])
plt.xlabel('Gender')
plt.ylabel('Count of Exited Individuals')
plt.title('Exited Individuals by Gender')
plt.legend(title='Exited Level')
plt.show()

import pandas as pd
import matplotlib.pyplot as plt

# Assuming 'df' is your DataFrame
gender_excited_counts = df.groupby('Age')['Exited'].value_counts().unstack()

# Create a bar chart
gender_excited_counts.plot(kind='bar', color=['red', 'blue'])
plt.xlabel('Age')
plt.ylabel('Count of Excited Individuals')
plt.title('Excited Individuals by Age')
plt.legend(title='Excited Level')
plt.show()